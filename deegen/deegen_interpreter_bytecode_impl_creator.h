#pragma once

#include "misc_llvm_helper.h"

namespace dast {

class BytecodeVariantDefinition;

enum class BytecodeIrComponentKind
{
    // This is the main function of the bytecode variant
    //
    Main,
    // This is a return continuation
    // The return continuation additionally has access to all the return values of the call
    //
    ReturnContinuation,
    // This is a quickened bytecode slow path
    //
    QuickeningSlowPath,
    // This is a slow path created by EnterSlowPath API
    //
    SlowPath,
    // This is an affliated bytecode created by FuseICIntoInterpreterOpcode() API
    //
    FusedInInlineCacheEffect
};

// Describes a subcomponent of a bytecode (the main function, a slow path, a quickening variant, etc)
//
struct BytecodeIrComponent
{
    // The type of this component
    //
    BytecodeIrComponentKind m_processKind;

    // The owning bytecode variant
    //
    BytecodeVariantDefinition* m_bytecodeDef;

    // The LLVM module, and the function in th module for this component
    //
    std::unique_ptr<llvm::Module> m_module;
    llvm::Function* m_impl;

    // The desired name of the resulted function after processing
    //
    std::string m_resultFuncName;

    // Construct a bytecode IR component
    // This function clones the module, so the original module is untouched.
    // The cloned module is owned by this class.
    //
    BytecodeIrComponent(BytecodeVariantDefinition* bytecodeDef, llvm::Function* impl, BytecodeIrComponentKind processKind);

    struct ProcessFusedInIcEffectTag { };

    // Construct a 'FusedIC' bytecode IR component
    // Need a special function because it takes an extra 'icEffectOrd' as argument
    //
    BytecodeIrComponent(ProcessFusedInIcEffectTag, BytecodeVariantDefinition* bytecodeDef, llvm::Function* impl, size_t icEffectOrd);

    // Run the deegen-level optimization passes
    //
    void DoOptimization();
};

// The class that holds all the LLVM IR information about one bytecode
//
struct BytecodeIrInfo
{
    // The bytecode variant of this bytecode
    //
    BytecodeVariantDefinition* m_bytecodeDef;

    // The main implementation function
    //
    std::unique_ptr<BytecodeIrComponent> m_mainComponent;

    // All the return continuation functions
    //
    std::vector<std::unique_ptr<BytecodeIrComponent>> m_allRetConts;

    // If the bytecode is a quickening one, this holds the slow path
    // Nullptr otherwise
    //
    std::unique_ptr<BytecodeIrComponent> m_quickeningSlowPath;

    // Holds all the slow paths generated by EnterSlowPath API
    // Note that the m_resultFuncName of these submodules may not be unique across translational units.
    // We will rename them after the Main processor links all the submodules together.
    //
    std::vector<std::unique_ptr<BytecodeIrComponent>> m_slowPaths;

    // This holds all the fused IC effect specializations, if any
    // Only useful for interpreter
    //
    std::vector<std::unique_ptr<BytecodeIrComponent>> m_fusedICs;

    // This stores all the additional affliated bytecodes functions, which should be
    // assigned opcode ordinal immediately following the main bytecode function in sequential order
    // Only useful for interpreter
    //
    std::vector<std::string> m_affliatedBytecodeFnNames;

    // This stores the function name of all the IC body
    // These functions are always defined in the main component
    //
    std::vector<std::string> m_icBodyNames;

    static BytecodeIrInfo WARN_UNUSED Create(BytecodeVariantDefinition* bytecodeDef, llvm::Function* mainImpl);
};

class InterpreterBytecodeImplCreator
{
public:
    // This clones the input module, so that the input module is untouched
    //
    InterpreterBytecodeImplCreator(BytecodeIrComponent& bic);

    // Inline 'impl' into the wrapper logic, then lower APIs like 'Return', 'MakeCall', 'Error', etc.
    //
    void DoLowering();

    static std::unique_ptr<InterpreterBytecodeImplCreator> WARN_UNUSED LowerOneComponent(BytecodeIrComponent& bic);
    static std::unique_ptr<llvm::Module> WARN_UNUSED DoLoweringForAll(BytecodeIrInfo& bi);

    bool IsReturnContinuation() const { return m_processKind == BytecodeIrComponentKind::ReturnContinuation; }
    BytecodeVariantDefinition* GetBytecodeDef() const { return m_bytecodeDef; }
    llvm::Module* GetModule() const { return m_module.get(); }
    llvm::Value* GetCoroutineCtx() const { return m_valuePreserver.Get(x_coroutineCtx); }
    llvm::Value* GetStackBase() const { return m_valuePreserver.Get(x_stackBase); }
    llvm::Value* GetCurBytecode() const { return m_valuePreserver.Get(x_curBytecode); }
    llvm::Value* GetCodeBlock() const { return m_valuePreserver.Get(x_codeBlock); }
    llvm::Value* GetRetStart() const { ReleaseAssert(IsReturnContinuation()); return m_valuePreserver.Get(x_retStart); }
    llvm::Value* GetNumRet() const { ReleaseAssert(IsReturnContinuation()); return m_valuePreserver.Get(x_numRet); }
    llvm::Value* GetOutputSlot() const { return m_valuePreserver.Get(x_outputSlot); }
    llvm::Value* GetCondBrDest() const { return m_valuePreserver.Get(x_condBrDest); }
    llvm::Value* GetBytecodeMetadataPtr() const { return m_valuePreserver.Get(x_metadataPtr); }

    llvm::CallInst* CallDeegenCommonSnippet(const std::string& dcsName, llvm::ArrayRef<llvm::Value*> args, llvm::Instruction* insertBefore)
    {
        return CreateCallToDeegenCommonSnippet(GetModule(), dcsName, args, insertBefore);
    }

    llvm::CallInst* CallDeegenRuntimeFunction(const std::string& dcsName, llvm::ArrayRef<llvm::Value*> args, llvm::Instruction* insertBefore)
    {
        return CreateCallToDeegenRuntimeFunction(GetModule(), dcsName, args, insertBefore);
    }

    static std::string WARN_UNUSED GetInterpreterBytecodeFunctionCName(BytecodeVariantDefinition* bytecodeDef);
    static std::string WARN_UNUSED GetInterpreterBytecodeReturnContinuationFunctionCName(BytecodeVariantDefinition* bytecodeDef, size_t rcOrd);
    static bool WARN_UNUSED IsFunctionReturnContinuationOfBytecode(llvm::Function* func, const std::string& bytecodeVariantMainFuncName);

    std::string WARN_UNUSED GetResultFunctionName() { return m_resultFuncName; }

    static constexpr const char* x_hot_code_section_name = "deegen_interpreter_code_section_hot";
    static constexpr const char* x_cold_code_section_name = "deegen_interpreter_code_section_cold";

private:
    void CreateWrapperFunction();
    void LowerGetBytecodeMetadataPtrAPI();

    BytecodeVariantDefinition* m_bytecodeDef;

    std::unique_ptr<llvm::Module> m_module;
    BytecodeIrComponentKind m_processKind;

    llvm::Function* m_impl;
    llvm::Function* m_wrapper;

    // The name of the wrapper function (i.e., the final product)
    //
    std::string m_resultFuncName;

    LLVMValuePreserver m_valuePreserver;
    bool m_generated;

    static constexpr const char* x_coroutineCtx = "coroutineCtx";
    static constexpr const char* x_stackBase = "stackBase";
    static constexpr const char* x_curBytecode = "curBytecode";
    static constexpr const char* x_codeBlock = "codeBlock";
    static constexpr const char* x_retStart = "retStart";
    static constexpr const char* x_numRet = "numRet";
    static constexpr const char* x_outputSlot = "outputSlot";
    static constexpr const char* x_condBrDest = "condBrDest";
    static constexpr const char* x_metadataPtr = "metadataPtr";
};

}   // namespace dast
